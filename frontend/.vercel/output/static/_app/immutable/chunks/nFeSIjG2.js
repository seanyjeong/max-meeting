var m=Object.defineProperty;var l=(c,e,t)=>e in c?m(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var f=(c,e,t)=>l(c,typeof e!="symbol"?e+"":e,t);import{e as E,P as A}from"./VgTo3XoD.js";import{g as y}from"./DzGFvkG0.js";const u=A,i=class i{static getInstance(){return i.instance||(i.instance=new i),i.instance}getHeaders(){const e={"Content-Type":"application/json"};if(typeof window<"u"){const t=localStorage.getItem("accessToken");t&&(e.Authorization=`Bearer ${t}`)}return e}async fetchWithAuth(e,t){let s;try{s=await fetch(e,t)}catch{throw new n("NETWORK_ERROR","서버에 연결할 수 없습니다",0)}if(s.status===401)if(await E()){const a=this.getHeaders(),h={...t,headers:a};let r;try{r=await fetch(e,h)}catch{throw new n("NETWORK_ERROR","서버에 연결할 수 없습니다",0)}if(!r.ok&&r.status!==401){const d=await this.parseErrorResponse(r);throw new n(d.code,d.message,r.status)}if(r.status===401)throw y("/login"),new n("UNAUTHORIZED","세션이 만료되었습니다",401);return r.status===204?void 0:r.json()}else throw y("/login"),new n("UNAUTHORIZED","세션이 만료되었습니다",401);if(!s.ok){const o=await this.parseErrorResponse(s);throw new n(o.code,o.message,s.status)}if(s.status!==204)return s.json()}async parseErrorResponse(e){var t;try{const s=await e.json();return(t=s.error)!=null&&t.code?{code:s.error.code,message:s.error.message||"알 수 없는 오류"}:s.detail?{code:"API_ERROR",message:s.detail}:s.message?{code:"API_ERROR",message:s.message}:{code:"API_ERROR",message:JSON.stringify(s)}}catch{return{code:"PARSE_ERROR",message:`HTTP ${e.status}: ${e.statusText}`}}}async get(e,t){let s=`${u}${e}`;if(t){const o=new URLSearchParams;Object.entries(t).forEach(([h,r])=>{r!==void 0&&o.append(h,String(r))});const a=o.toString();a&&(s+=`?${a}`)}return this.fetchWithAuth(s,{method:"GET",headers:this.getHeaders()})}async post(e,t){return this.fetchWithAuth(`${u}${e}`,{method:"POST",headers:this.getHeaders(),body:t?JSON.stringify(t):void 0})}async patch(e,t){return this.fetchWithAuth(`${u}${e}`,{method:"PATCH",headers:this.getHeaders(),body:JSON.stringify(t)})}async put(e,t){return this.fetchWithAuth(`${u}${e}`,{method:"PUT",headers:this.getHeaders(),body:JSON.stringify(t)})}async delete(e){return this.fetchWithAuth(`${u}${e}`,{method:"DELETE",headers:this.getHeaders()})}async uploadChunk(e,t,s,o){var R,w;const a={"Content-Type":t.type||"audio/webm","Upload-Offset":String(s),"Content-Length":String(t.size),"Upload-Length":String(o)},h=localStorage.getItem("accessToken");h&&(a.Authorization=`Bearer ${h}`),console.log("[API] uploadChunk 시작:",{recordingId:e,offset:s,chunkSize:t.size,totalSize:o,mimeType:t.type});const r=await fetch(`${u}/recordings/${e}/upload`,{method:"POST",headers:a,body:t});if(!r.ok){let g;try{g=await r.json()}catch{g={error:{message:`HTTP ${r.status}`}}}throw console.error("[API] uploadChunk 실패:",{status:r.status,error:g}),new n(((R=g.error)==null?void 0:R.code)||"UPLOAD_ERROR",((w=g.error)==null?void 0:w.message)||"Upload failed",r.status)}const d=await r.json();return console.log("[API] uploadChunk 완료:",d),d}};f(i,"instance");let p=i;class n extends Error{constructor(t,s,o){super(s);f(this,"code");f(this,"status");this.code=t,this.status=o,this.name="ApiError"}}const S=p.getInstance();export{S as a};
